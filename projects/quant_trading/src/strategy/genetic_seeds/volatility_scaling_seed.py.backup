"""
Volatility Scaling Genetic Seed - Seed #9

This seed implements volatility regime detection and adaptive position scaling.
The genetic algorithm evolves optimal volatility thresholds and scaling factors
for different market regimes.

Key Features:
- Regime-based volatility detection with genetic parameters
- Adaptive position sizing based on volatility clusters
- Multi-timeframe volatility analysis
- Dynamic risk scaling
"""

from typing import Dict, List, Tuple
import pandas as pd
import numpy as np

from .base_seed import BaseSeed, SeedType, SeedGenes
from .seed_registry import genetic_seed
from src.config.settings import Settings, Optional


@genetic_seed
class VolatilityScalingSeed(BaseSeed):
    """Volatility scaling seed with genetic regime detection."""
    
    @property
    def seed_name(self) -> str:
        """Return human-readable seed name."""
        return "Volatility_Scaling"
    
    @property
    def seed_description(self) -> str:
        """Return detailed seed description."""
        return ("Volatility regime detection and adaptive position scaling. "
                "Scales position sizes based on volatility clusters and market regimes. "
                "Uses genetic algorithms to optimize volatility thresholds and scaling factors.")
    
    @property
    def required_parameters(self) -> List[str]:
        """Return list of required genetic parameters."""
        return [
            'volatility_window',
            'regime_threshold',
            'scaling_factor',
            'regime_persistence',
            'multi_timeframe_weight'
        ]
    
    @property
    def parameter_bounds(self) -> Dict[str, Tuple[float, float]]:
        """Return bounds for genetic parameters (min, max)."""
        return {
            'volatility_window': (10.0, 100.0),      # Volatility calculation window
            'regime_threshold': (0.5, 3.0),          # Volatility regime threshold multiplier
            'scaling_factor': (0.1, 2.0),            # Position scaling factor
            'regime_persistence': (2.0, 20.0),       # Regime persistence bars
            'multi_timeframe_weight': (0.0, 1.0)     # Multi-timeframe analysis weight
        }
    
    def __init__(self, genes: SeedGenes, settings: Optional[Settings] = None):
        """Initialize volatility scaling seed.
        
        Args:
            genes: Genetic parameters
            settings: Configuration settings
        """
        # Set seed type
        genes.seed_type = SeedType.VOLATILITY
        
        # Initialize default parameters if not provided
        if not genes.parameters:
            genes.parameters = {
                'volatility_window': 20.0,
                'regime_threshold': 1.5,
                'scaling_factor': 0.5,
                'regime_persistence': 5.0,
                'multi_timeframe_weight': 0.3
            }
        
        super().__init__(genes, settings)
    
    def calculate_technical_indicators(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
        """Calculate volatility indicators and regime metrics.
        
        Args:
            data: OHLCV market data
            
        Returns:
            Dictionary of indicator name -> indicator values
        """
        # Get genetic parameters
        vol_window = int(self.genes.parameters['volatility_window'])
        regime_threshold = self.genes.parameters['regime_threshold']
        mtf_weight = self.genes.parameters['multi_timeframe_weight']
        
        # Calculate price returns
        returns = data['close'].pct_change()
        
        # Primary volatility measure (rolling standard deviation)
        volatility = returns.rolling(window=vol_window).std()
        
        # Multi-timeframe volatility analysis
        short_vol = returns.rolling(window=vol_window//2).std()
        long_vol = returns.rolling(window=vol_window*2).std()
        
        # Volatility regime detection
        vol_ma = volatility.rolling(window=vol_window).mean()
        vol_threshold = vol_ma * regime_threshold
        
        # High volatility regime
        high_vol_regime = volatility > vol_threshold
        
        # Low volatility regime  
        low_vol_regime = volatility < (vol_ma * (1/regime_threshold))
        
        # Regime persistence
        persistence_window = int(self.genes.parameters['regime_persistence'])
        high_vol_persistent = high_vol_regime.rolling(window=persistence_window).sum() >= persistence_window//2
        low_vol_persistent = low_vol_regime.rolling(window=persistence_window).sum() >= persistence_window//2
        
        # Volatility clustering detection
        vol_acceleration = volatility.diff()
        vol_cluster = vol_acceleration > vol_acceleration.rolling(window=20).quantile(0.8)
        
        # Price momentum for regime confirmation
        price_momentum = data['close'].pct_change(periods=5)
        
        # Multi-timeframe volatility ratio
        if mtf_weight > 0.1:
            # Calculate daily volatility (assuming hourly data)
            daily_vol = returns.rolling(window=24).std() if len(data) > 24 else volatility
            vol_ratio = volatility / daily_vol
        else:
            vol_ratio = pd.Series(1.0, index=data.index)
        
        # Average True Range (ATR) for additional volatility measure
        high_low = data['high'] - data['low']
        high_close = abs(data['high'] - data['close'].shift(1))
        low_close = abs(data['low'] - data['close'].shift(1))
        
        true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        atr = true_range.rolling(window=vol_window).mean()
        atr_ratio = atr / data['close']
        
        return {
            'volatility': volatility.fillna(0.02),  # Default 2% volatility
            'short_vol': short_vol.fillna(0.02),
            'long_vol': long_vol.fillna(0.02),
            'vol_ma': vol_ma.fillna(0.02),
            'vol_threshold': vol_threshold.fillna(0.03),
            'high_vol_regime': high_vol_persistent.fillna(False),
            'low_vol_regime': low_vol_persistent.fillna(False),
            'vol_cluster': vol_cluster.fillna(False),
            'price_momentum': price_momentum.fillna(0),
            'vol_ratio': vol_ratio.fillna(1.0),
            'atr': atr.fillna(0.02),
            'atr_ratio': atr_ratio.fillna(0.02),
            'returns': returns.fillna(0)
        }
    
    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """Generate volatility-based trading signals.
        
        Args:
            data: OHLCV market data
            
        Returns:
            Series of trading signals: -1 to 1 (signal strength)
        """
        # Calculate technical indicators
        indicators = self.calculate_technical_indicators(data)
        
        # Get genetic parameters
        scaling_factor = self.genes.parameters['scaling_factor']
        mtf_weight = self.genes.parameters['multi_timeframe_weight']
        
        # Initialize scaling signals
        scaling_signals = pd.Series(1.0, index=data.index)  # Default no scaling
        
        # High volatility regime: reduce position sizes
        high_vol_mask = indicators['high_vol_regime']
        scaling_signals[high_vol_mask] = scaling_factor
        
        # Low volatility regime: potentially increase position sizes
        low_vol_mask = indicators['low_vol_regime']
        scaling_signals[low_vol_mask] = min(1.0 / scaling_factor, 2.0)  # Cap at 2x
        
        # Volatility clustering: further reduce positions
        cluster_mask = indicators['vol_cluster']
        scaling_signals[cluster_mask] = scaling_signals[cluster_mask] * 0.7
        
        # Multi-timeframe adjustment
        if mtf_weight > 0.1:
            vol_ratio = indicators['vol_ratio']
            
            # When short-term vol > long-term vol: reduce positions
            high_ratio_mask = vol_ratio > 1.2
            scaling_signals[high_ratio_mask] = scaling_signals[high_ratio_mask] * (1 - mtf_weight * 0.3)
            
            # When short-term vol < long-term vol: increase positions
            low_ratio_mask = vol_ratio < 0.8
            scaling_signals[low_ratio_mask] = scaling_signals[low_ratio_mask] * (1 + mtf_weight * 0.2)
        
        # ATR-based additional scaling
        atr_ratio = indicators['atr_ratio']
        high_atr = atr_ratio > atr_ratio.rolling(50).quantile(0.8)
        scaling_signals[high_atr] = scaling_signals[high_atr] * 0.8
        
        # Convert scaling factors to trading signals [-1, 1]
        # High volatility = negative signal (avoid trading)
        # Low volatility = positive signal (favorable for trading)
        
        # Normalize scaling_signals from [0.1, 2.0] to [-1, 1]
        # scaling_signals > 1.0 means favorable (low vol) -> positive signal
        # scaling_signals < 1.0 means unfavorable (high vol) -> negative signal
        
        trading_signals = pd.Series(0.0, index=data.index)
        
        # Map scaling factors to trading signals
        # 2.0 -> +1.0 (maximum positive signal in low vol regime)
        # 1.0 -> 0.0 (neutral)
        # 0.1 -> -1.0 (maximum negative signal in high vol regime)
        
        trading_signals = (scaling_signals - 1.0)  # Center around 0
        trading_signals = trading_signals.clip(-0.9, 1.0)  # Ensure within [-1, 1] range
        
        # Add momentum-based signal enhancement
        momentum = indicators['price_momentum']
        momentum_signals = momentum.clip(-0.1, 0.1) * 10  # Convert to [-1, 1] range
        
        # Combine volatility and momentum signals
        combined_signals = trading_signals * 0.7 + momentum_signals * 0.3
        
        # Final clipping and NaN handling
        combined_signals = combined_signals.clip(-1.0, 1.0)
        combined_signals = combined_signals.fillna(0.0)
        
        return combined_signals
    
    def get_volatility_regime(self, data: pd.DataFrame) -> pd.Series:
        """Get current volatility regime classification.
        
        Args:
            data: OHLCV market data
            
        Returns:
            Series of regime classifications: 'low', 'normal', 'high', 'extreme'
        """
        indicators = self.calculate_technical_indicators(data)
        
        volatility = indicators['volatility']
        vol_ma = indicators['vol_ma']
        
        # Regime classification
        regimes = pd.Series('normal', index=data.index)
        
        # Low volatility (< 0.67 * average)
        low_vol = volatility < (vol_ma * 0.67)
        regimes[low_vol] = 'low'
        
        # High volatility (> 1.5 * average)
        high_vol = volatility > (vol_ma * 1.5)
        regimes[high_vol] = 'high'
        
        # Extreme volatility (> 2.0 * average)
        extreme_vol = volatility > (vol_ma * 2.0)
        regimes[extreme_vol] = 'extreme'
        
        return regimes
    
    def calculate_position_size(self, data: pd.DataFrame, signal: float) -> float:
        """Calculate position size based on volatility regime.
        
        Args:
            data: Current market data
            signal: Base signal strength (-1 to 1)
            
        Returns:
            Adjusted position size as percentage of capital
        """
        if abs(signal) < self.genes.filter_threshold:
            return 0.0
        
        # Get volatility scaling factor
        scaling_signals = self.generate_signals(data.tail(10))  # Last 10 bars
        current_scaling = scaling_signals.iloc[-1] if len(scaling_signals) > 0 else 1.0
        
        # Base position size from genes
        base_size = self.genes.position_size
        
        # Apply volatility scaling
        adjusted_size = base_size * current_scaling * abs(signal)
        
        # Apply maximum position size limit
        max_size = self.settings.trading.max_position_size
        return min(adjusted_size, max_size)
    
    def get_risk_adjustment_factor(self, data: pd.DataFrame) -> float:
        """Get risk adjustment factor based on current volatility regime.
        
        Args:
            data: Current market data
            
        Returns:
            Risk adjustment factor (0.1 to 2.0)
        """
        regime = self.get_volatility_regime(data.tail(5))  # Last 5 bars
        latest_regime = regime.iloc[-1] if len(regime) > 0 else 'normal'
        
        # Risk adjustment based on regime
        risk_adjustments = {
            'low': 1.5,      # Can take more risk in low vol
            'normal': 1.0,   # Normal risk
            'high': 0.6,     # Reduce risk in high vol
            'extreme': 0.3   # Severely reduce risk in extreme vol
        }
        
        return risk_adjustments.get(latest_regime, 1.0)
    
    def __str__(self) -> str:
        """String representation with genetic parameters."""
        vol_window = self.genes.parameters.get('volatility_window', 20)
        regime_threshold = self.genes.parameters.get('regime_threshold', 1.5)
        scaling_factor = self.genes.parameters.get('scaling_factor', 0.5)
        
        fitness_str = f" (fitness={self.fitness.composite_fitness:.3f})" if self.fitness else ""
        return f"VolScaling(win={vol_window:.0f},thr={regime_threshold:.2f},scale={scaling_factor:.2f}){fitness_str}"