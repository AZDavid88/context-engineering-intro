"""
Base Genetic Seed Framework

This module provides the foundational framework for all genetic seeds in the
trading organism. Each seed represents a fundamental trading primitive that
can be evolved by genetic algorithms.

Key Features:
- Standardized seed interface for genetic evolution
- Multi-objective fitness evaluation
- Type-safe parameter validation
- Production-ready error handling
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Any, Union
from datetime import datetime, timezone
from enum import Enum
import numpy as np
import pandas as pd
from pydantic import BaseModel, Field, validator

from src.config.settings import get_settings, Settings


class SeedType(str, Enum):
    """Types of genetic seeds."""
    
    MOMENTUM = "momentum"           # Trend-following strategies
    MEAN_REVERSION = "mean_reversion"  # Contrarian strategies
    BREAKOUT = "breakout"          # Breakout detection
    RISK_MANAGEMENT = "risk_management"  # Stop losses, position sizing
    CARRY = "carry"                # Funding rate exploitation
    ML_CLASSIFIER = "ml_classifier"  # Machine learning based
    VOLATILITY = "volatility"      # Volatility-based strategies
    VOLUME = "volume"              # Volume-based signals
    TREND_FOLLOWING = "trend_following"  # Trend-following strategies


class SeedGenes(BaseModel):
    """Genetic parameters for a trading seed."""
    
    # Core identification
    seed_id: str = Field(..., description="Unique seed identifier")
    seed_type: SeedType = Field(..., description="Type of trading seed")
    generation: int = Field(default=0, ge=0, description="Generation number")
    
    # Genetic parameters (evolved by GA)
    parameters: Dict[str, float] = Field(default_factory=dict, description="Evolved parameters")
    
    # Technical indicator periods
    fast_period: int = Field(default=12, ge=2, le=100, description="Fast moving average period")
    slow_period: int = Field(default=26, ge=5, le=200, description="Slow moving average period")
    signal_period: int = Field(default=9, ge=2, le=50, description="Signal line period")
    
    # Thresholds and filters
    entry_threshold: float = Field(default=0.0, ge=-1.0, le=1.0, description="Entry signal threshold")
    exit_threshold: float = Field(default=0.0, ge=-1.0, le=1.0, description="Exit signal threshold")
    filter_threshold: float = Field(default=0.5, ge=0.0, le=1.0, description="Signal filter threshold")
    
    # Risk management
    stop_loss: float = Field(default=0.02, ge=0.001, le=0.1, description="Stop loss percentage")
    take_profit: float = Field(default=0.04, ge=0.005, le=0.2, description="Take profit percentage")
    
    # Position sizing
    position_size: float = Field(default=0.1, ge=0.01, le=0.25, description="Position size percentage")
    
    @validator('parameters')
    @classmethod
    def validate_parameters(cls, v):
        """Validate that all parameters are numeric."""
        for key, value in v.items():
            if not isinstance(value, (int, float)):
                raise ValueError(f"Parameter {key} must be numeric")
        return v


class SeedFitness(BaseModel):
    """Fitness evaluation results for a genetic seed."""
    
    # Primary fitness metrics (multi-objective)
    sharpe_ratio: float = Field(..., description="Sharpe ratio (higher is better)")
    max_drawdown: float = Field(..., description="Maximum drawdown (lower is better)")
    win_rate: float = Field(..., ge=0.0, le=1.0, description="Win rate (0-1)")
    consistency: float = Field(..., ge=0.0, le=1.0, description="Consistency score (0-1)")
    
    # Auxiliary metrics
    total_return: float = Field(..., description="Total return percentage")
    volatility: float = Field(..., ge=0.0, description="Return volatility")
    profit_factor: float = Field(..., ge=0.0, description="Profit factor (>1 profitable)")
    
    # Trade statistics
    total_trades: int = Field(..., ge=0, description="Total number of trades")
    avg_trade_duration: float = Field(..., ge=0.0, description="Average trade duration (hours)")
    max_consecutive_losses: int = Field(..., ge=0, description="Maximum consecutive losses")
    
    # Composite fitness score
    composite_fitness: float = Field(..., description="Weighted composite fitness score")
    
    # Validation across periods
    in_sample_fitness: float = Field(..., description="In-sample fitness score")
    out_of_sample_fitness: float = Field(..., description="Out-of-sample fitness score")
    walk_forward_fitness: float = Field(..., description="Walk-forward fitness score")
    
    @validator('composite_fitness', pre=True, always=True)
    @classmethod
    def calculate_composite_fitness(cls, v, values):
        """Calculate weighted composite fitness score."""
        if not all(key in values for key in ['sharpe_ratio', 'max_drawdown', 'win_rate', 'consistency']):
            return 0.0
        
        # Multi-objective fitness weights from consultant recommendations
        weights = {
            'sharpe_ratio': 0.5,     # Primary: Risk-adjusted returns
            'max_drawdown': 0.3,     # Critical: Risk management
            'win_rate': 0.15,        # Secondary: Consistency
            'consistency': 0.05      # Stability over time
        }
        
        # Normalize components to 0-1 scale
        sharpe_component = max(0, min(values['sharpe_ratio'] / 5.0, 1.0))  # Max Sharpe ~5
        drawdown_component = max(0, 1.0 - values['max_drawdown'])  # Lower is better
        win_rate_component = values['win_rate']  # Already 0-1
        consistency_component = values['consistency']  # Already 0-1
        
        # Calculate weighted composite
        composite = (
            weights['sharpe_ratio'] * sharpe_component +
            weights['max_drawdown'] * drawdown_component +
            weights['win_rate'] * win_rate_component +
            weights['consistency'] * consistency_component
        )
        
        return max(0.0, min(1.0, composite))  # Clamp to 0-1 range


class BaseSeed(ABC):
    """Base class for all genetic trading seeds."""
    
    def __init__(self, genes: SeedGenes, settings: Optional[Settings] = None):
        """Initialize seed with genetic parameters.
        
        Args:
            genes: Genetic parameters for this seed
            settings: Configuration settings
        """
        self.genes = genes
        self.settings = settings or get_settings()
        self.fitness: Optional[SeedFitness] = None
        
        # Validation
        self._validate_seed()
    
    @property
    @abstractmethod
    def seed_name(self) -> str:
        """Return human-readable seed name."""
        pass
    
    @property
    @abstractmethod
    def seed_description(self) -> str:
        """Return detailed seed description."""
        pass
    
    @property
    @abstractmethod
    def required_parameters(self) -> List[str]:
        """Return list of required genetic parameters."""
        pass
    
    @property
    @abstractmethod
    def parameter_bounds(self) -> Dict[str, Tuple[float, float]]:
        """Return bounds for genetic parameters (min, max)."""
        pass
    
    def _validate_seed(self) -> None:
        """Validate seed configuration."""
        # Check required parameters
        for param in self.required_parameters:
            if param not in self.genes.parameters:
                raise ValueError(f"Required parameter '{param}' missing from genes")
        
        # Check parameter bounds
        for param, (min_val, max_val) in self.parameter_bounds.items():
            if param in self.genes.parameters:
                value = self.genes.parameters[param]
                if not (min_val <= value <= max_val):
                    raise ValueError(f"Parameter '{param}' value {value} outside bounds [{min_val}, {max_val}]")
    
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """Generate trading signals from market data.
        
        Args:
            data: OHLCV market data with columns: open, high, low, close, volume
            
        Returns:
            Series of trading signals: 1 (buy), 0 (hold), -1 (sell)
        """
        pass
    
    @abstractmethod
    def calculate_technical_indicators(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
        """Calculate technical indicators used by this seed.
        
        Args:
            data: OHLCV market data
            
        Returns:
            Dictionary of indicator name -> indicator values
        """
        pass
    
    def get_entry_signals(self, data: pd.DataFrame) -> pd.Series:
        """Get entry signals (buy/sell).
        
        Args:
            data: OHLCV market data
            
        Returns:
            Series of entry signals: 1 (buy), -1 (sell), 0 (no signal)
        """
        signals = self.generate_signals(data)
        # Entry signals are transitions from 0 to 1/-1
        entry_signals = signals.diff()
        return entry_signals.fillna(0)
    
    def get_exit_signals(self, data: pd.DataFrame, positions: pd.Series) -> pd.Series:
        """Get exit signals based on current positions.
        
        Args:
            data: OHLCV market data
            positions: Current position states (1, 0, -1)
            
        Returns:
            Series of exit signals: 1 (exit long), -1 (exit short), 0 (hold)
        """
        signals = self.generate_signals(data)
        # Exit when signal changes from non-zero to zero
        exit_signals = pd.Series(0, index=data.index)
        
        # Exit long positions when signal becomes 0 or negative
        long_exits = (positions == 1) & (signals <= 0)
        exit_signals[long_exits] = 1
        
        # Exit short positions when signal becomes 0 or positive
        short_exits = (positions == -1) & (signals >= 0)
        exit_signals[short_exits] = -1
        
        return exit_signals
    
    def apply_risk_management(self, data: pd.DataFrame, signals: pd.Series) -> pd.Series:
        """Apply risk management rules to signals.
        
        Args:
            data: OHLCV market data
            signals: Raw trading signals
            
        Returns:
            Risk-adjusted trading signals
        """
        # Basic stop loss implementation
        adjusted_signals = signals.copy()
        
        # Calculate price changes for stop loss
        returns = data['close'].pct_change()
        
        # Apply stop loss
        stop_loss_threshold = self.genes.stop_loss
        cumulative_return = 0.0
        position = 0
        
        for i in range(len(adjusted_signals)):
            if position == 0:  # No position
                if signals.iloc[i] != 0:
                    position = signals.iloc[i]
                    cumulative_return = 0.0
            else:  # In position
                # Update cumulative return
                cumulative_return += returns.iloc[i] * position
                
                # Check stop loss
                if cumulative_return <= -stop_loss_threshold:
                    adjusted_signals.iloc[i] = 0  # Exit position
                    position = 0
                    cumulative_return = 0.0
                elif signals.iloc[i] == 0:  # Normal exit
                    position = 0
                    cumulative_return = 0.0
        
        return adjusted_signals
    
    def calculate_position_size(self, data: pd.DataFrame, signal: float) -> float:
        """Calculate position size based on signal strength and risk parameters.
        
        Args:
            data: Current market data
            signal: Signal strength (-1 to 1)
            
        Returns:
            Position size as percentage of capital (0 to max_position_size)
        """
        if abs(signal) < self.genes.filter_threshold:
            return 0.0
        
        # Base position size from genes
        base_size = self.genes.position_size
        
        # Scale by signal strength
        position_size = base_size * abs(signal)
        
        # Apply maximum position size limit
        max_size = self.settings.trading.max_position_size
        return min(position_size, max_size)
    
    def evaluate_fitness(self, backtest_results: Dict[str, Any]) -> SeedFitness:
        """Evaluate fitness based on backtest results.
        
        Args:
            backtest_results: Results from vectorbt backtesting
            
        Returns:
            Fitness evaluation
        """
        # Extract metrics from backtest results
        # This will integrate with vectorbt Portfolio results
        
        # Placeholder implementation - will be enhanced with actual vectorbt integration
        sharpe_ratio = backtest_results.get('sharpe_ratio', 0.0)
        max_drawdown = backtest_results.get('max_drawdown', 1.0)
        win_rate = backtest_results.get('win_rate', 0.0)
        total_return = backtest_results.get('total_return', 0.0)
        volatility = backtest_results.get('volatility', 0.0)
        total_trades = backtest_results.get('total_trades', 0)
        
        # Calculate consistency (placeholder)
        consistency = max(0.0, min(1.0, win_rate * (1.0 - max_drawdown)))
        
        # Create fitness object
        fitness = SeedFitness(
            sharpe_ratio=sharpe_ratio,
            max_drawdown=max_drawdown,
            win_rate=win_rate,
            consistency=consistency,
            total_return=total_return,
            volatility=volatility,
            profit_factor=max(0.0, total_return / max(abs(total_return - total_return), 0.01)),
            total_trades=total_trades,
            avg_trade_duration=24.0,  # Placeholder
            max_consecutive_losses=5,  # Placeholder
            composite_fitness=0.0,  # Will be calculated by validator
            in_sample_fitness=sharpe_ratio * 0.8,  # Placeholder
            out_of_sample_fitness=sharpe_ratio * 0.6,  # Placeholder
            walk_forward_fitness=sharpe_ratio * 0.7  # Placeholder
        )
        
        self.fitness = fitness
        return fitness
    
    def mutate(self, mutation_rate: float = 0.1) -> 'BaseSeed':
        """Create a mutated copy of this seed.
        
        Args:
            mutation_rate: Probability of mutating each parameter
            
        Returns:
            New seed with mutated parameters
        """
        import random
        import copy
        
        # Create a copy of genes
        new_genes = copy.deepcopy(self.genes)
        new_genes.generation += 1
        
        # Mutate parameters
        for param_name, (min_val, max_val) in self.parameter_bounds.items():
            if param_name in new_genes.parameters and random.random() < mutation_rate:
                # Gaussian mutation with 10% standard deviation
                current_value = new_genes.parameters[param_name]
                std_dev = (max_val - min_val) * 0.1
                new_value = current_value + random.gauss(0, std_dev)
                
                # Clamp to bounds
                new_value = max(min_val, min(max_val, new_value))
                new_genes.parameters[param_name] = new_value
        
        # Create new seed instance
        return self.__class__(new_genes, self.settings)
    
    def crossover(self, other: 'BaseSeed') -> Tuple['BaseSeed', 'BaseSeed']:
        """Create two offspring through crossover with another seed.
        
        Args:
            other: Another seed of the same type
            
        Returns:
            Tuple of two offspring seeds
        """
        import random
        import copy
        
        if type(other) != type(self):
            raise ValueError("Cannot crossover seeds of different types")
        
        # Create offspring genes
        child1_genes = copy.deepcopy(self.genes)
        child2_genes = copy.deepcopy(other.genes)
        
        child1_genes.generation = max(self.genes.generation, other.genes.generation) + 1
        child2_genes.generation = max(self.genes.generation, other.genes.generation) + 1
        
        # Single-point crossover on parameters
        param_names = list(self.parameter_bounds.keys())
        if param_names:
            crossover_point = random.randint(1, len(param_names) - 1)
            
            for i, param_name in enumerate(param_names):
                if param_name in self.genes.parameters and param_name in other.genes.parameters:
                    if i < crossover_point:
                        # Keep parent assignments
                        pass
                    else:
                        # Swap parameter values
                        child1_genes.parameters[param_name] = other.genes.parameters[param_name]
                        child2_genes.parameters[param_name] = self.genes.parameters[param_name]
        
        # Create offspring instances
        child1 = self.__class__(child1_genes, self.settings)
        child2 = self.__class__(child2_genes, self.settings)
        
        return child1, child2
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert seed to dictionary representation."""
        return {
            'seed_name': self.seed_name,
            'seed_type': self.genes.seed_type.value,
            'genes': self.genes.dict(),
            'fitness': self.fitness.dict() if self.fitness else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any], settings: Optional[Settings] = None) -> 'BaseSeed':
        """Create seed from dictionary representation."""
        genes = SeedGenes(**data['genes'])
        return cls(genes, settings)
    
    def __str__(self) -> str:
        """String representation of seed."""
        fitness_str = f" (fitness={self.fitness.composite_fitness:.3f})" if self.fitness else ""
        return f"{self.seed_name}[gen={self.genes.generation}]{fitness_str}"
    
    def __repr__(self) -> str:
        """Detailed string representation."""
        return f"{self.__class__.__name__}(genes={self.genes}, fitness={self.fitness})"